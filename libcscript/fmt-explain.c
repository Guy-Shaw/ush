/*
 * Filename: fmt-explain.c
 * Library: libcscript
 * Brief: Reformat an explanation generated by libexplain
 *
 * Description:
 *   Given an explanation generated by libexplain,
 *   reformat it so that certain grammatical/logical clauses
 *   are on a sparate line.  Also, reformat it to make it stand out.
 *
 * Copyright (C) 2016 Guy Shaw
 * Written by Guy Shaw <gshaw@acm.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(__GNUC__) && !defined(_GNU_SOURCE)
#define _GNU_SOURCE 1
#endif

#include <cscript.h>
#include <stdbool.h>
    // Import constant true
    // Import type bool
#include <unistd.h>
    // Import isatty()

/**
 * @brief Reformat a |libexplain| message buffer, to break in logical places.
 * @param msg  IN,OUT  The original message, which _may_ be modified in place.
 * @return void
 *
 * |libexplain| produces messages without line breaks.  Those messages
 * can be rather long.  We break up a |libexplain| message in a few
 * strategid places.
 *
 * For example, it is common to start with the name function that failed,
 * along with its argument list in parentheses.  explain_fmt_fopen()
 * breaks after the comma immediately after the argument list.
 *
 * Later: |libcscript| will use a modified version of |libexplain|
 * that produces a pair of values:
 *   1) A list of properties and values;
 *   2) A message template with reference to property (key->value) entries.
 * But for now, we reformat.
 *
 */

void
explain_fmt_fopen(char *msg)
{
    char *line;
    char *s;
    char *word;
    int lvl;
    int grp;
    int c, prevc;
    int col;
    bool color;
    bool in_color;

    color = isatty(fileno(errprint_fh));
    in_color = false;
    s = msg;
    line = msg;
    word = msg;
    grp = 0;
    lvl = 0;
    col = 0;
    while ((c = *s) != 0) {
        if (c == '\n') {
            line = s + 1;
            col = 0;
            continue;
        }
        if (c == '(') {
            ++lvl;
        }
        else if (c == ')') {
            ++grp;
            --lvl;
        }
        if (c != ' ' && prevc == ' ') {
            word = s;
            if (word - line > 80 && col > 80 && lvl <= 0) {
                s[-1] = '\0';
                if (color && !in_color) {
                    error_msg_start();
                    in_color = true;
                }
                fputs(line, errprint_fh);
                putc('\n', errprint_fh);
                line = s + 1;
                col = 0;
            }
        }
        if (c == ' ' && (prevc == ',' || prevc == ';') && lvl <= 0) {
            *s = '\0';
            if (color && !in_color) {
                error_msg_start();
                in_color = true;
            }
            fputs(line, errprint_fh);
            putc('\n', errprint_fh);
            line = s + 1;
            col = 0;
        }
        if (c == ' ' && prevc == ')' && grp >= 2) {
            *s = '\0';
            if (color && !in_color) {
                error_msg_start();
                in_color = true;
            }
            fputs(line, errprint_fh);
            putc('\n', errprint_fh);
            line = s + 1;
            col = 0;
        }
        prevc = c;
        ++s;
        ++col;
    }

    if (color && !in_color) {
        error_msg_start();
        in_color = true;
    }
    fputs(line, errprint_fh);
    putc('\n', errprint_fh);
    if (in_color) {
        error_msg_finish();
    }
}
